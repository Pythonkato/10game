<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<title>10 Game — DecaMerge (Circles) v5.3-noBelts</title>
<meta name="theme-color" content="#F6F5F3">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAukB9Wj1nZkAAAAASUVORK5CYII=">

<!-- Manifest (inline) -->
<script type="application/manifest+json">
{
  "name": "10 Game — DecaMerge (Circles)",
  "short_name": "10 Game",
  "start_url": ".",
  "display": "standalone",
  "background_color": "#F6F5F3",
  "theme_color": "#F6F5F3",
  "icons": [
    {"src":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAukB9Wj1nZkAAAAASUVORK5CYII=","sizes":"192x192","type":"image/png"}
  ]
}
</script>

<style>
  :root{
    /* Runway-ish palette */
    --bg:#F6F5F3; --paper:#FFFFFF; --ink:#111; --muted:#6D6D70; --line:#E6E3DE; --chip:#FCFAF7;

    /* 小オーブ(1〜9)の塗り色（見分けやすい落ち着きトーン） */
    --n1:#D39F8A; --n2:#D7B18A; --n3:#D9C78A; --n4:#AFC7B7; --n5:#BFD5E8;
    --n6:#AEBEE0; --n7:#C2B6DE; --n8:#D9A8C6; --n9:#C6B18B;

    /* 大オーブ(10+)の塗り色（控えめグレイ） */
    --b10:#2E2E2E; --b20:#3A3A3A; --b40:#4A4A4A; --b80:#595959; --b160:#6A6A6A; --b320:#7B7B7B; --b640:#8C8C8C;

    /* ★ 数字（文字）の色を値ごとに：強めの色相で差別化 */
    --t1:#D94E41; --t2:#DE7B3B; --t3:#D9B12F; --t4:#2F9E7E; --t5:#3A83D6;
    --t6:#5C6CD8; --t7:#8F68D6; --t8:#D954A7; --t9:#A8793A;
    --t10:#0F7A55; --t20:#0A6CAA; --t40:#5B4BD1; --t80:#C23A6E; --t160:#B06E1F; --t320:#2A66C6; --t640:#248D5B; --t1280:#0E4F8E;
  }
  *{box-sizing:border-box}
  html,body{
    height:100%; margin:0; color:var(--ink);
    background:
      radial-gradient(1200px 600px at 50% -10%, #FFF, var(--bg) 55%),
      linear-gradient(180deg, rgba(0,0,0,0.02), rgba(0,0,0,0) 120px);
    font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "SF Pro Text",
      "Helvetica Neue", "Segoe UI", Roboto, "Noto Sans JP", Arial, sans-serif;
  }
  #wrap{min-height:100%;display:flex;flex-direction:column}

  header{
    padding:14px 16px;display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
    border-bottom:1px solid var(--line)
  }
  .brand{display:flex;align-items:baseline;gap:14px}
  .ttl{letter-spacing:.18em;text-transform:uppercase;font-weight:800;font-size:18px}
  .sub{color:var(--muted);font-size:12px;letter-spacing:.12em;text-transform:uppercase}

  .chips{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .chip{background:var(--chip);border:1px solid var(--line);padding:8px 12px;border-radius:999px;font-variant-numeric:tabular-nums}
  .btn{border:1px solid var(--line);padding:8px 14px;border-radius:999px;background:#fff;font-weight:700;letter-spacing:.08em}
  .btn.strong{border-color:var(--ink);background:var(--ink);color:#fff}
  .btn.ghost{background:#fff}
  .btn:disabled{opacity:.45}

  .nextBadge{
    display:flex;align-items:center;gap:10px;background:#fff;border:1px solid var(--line);color:var(--ink);
    border-radius:999px;padding:8px 12px;font-weight:800;letter-spacing:.08em
  }
  .nextBubble{
    width:36px;height:36px;border-radius:50%;
    background:conic-gradient(from 210deg, rgba(0,0,0,.08), rgba(0,0,0,0) 45%);
    display:grid;place-items:center;font-size:18px;border:1px solid var(--line)
  }

  #stage{flex:1;display:flex;align-items:center;justify-content:center;padding:14px}
  canvas{touch-action:none;background:var(--paper);border:1px solid var(--line);border-radius:18px;box-shadow:0 10px 48px rgba(0,0,0,.06)}

  footer{padding:12px 16px;border-top:1px solid var(--line);color:var(--muted);font-size:13px;text-align:center;letter-spacing:.02em}

  .toast{position:fixed;left:50%;bottom:22px;transform:translateX(-50%);
    background:#111;color:#fff;border-radius:999px;padding:10px 14px;opacity:0;transition:.25s;letter-spacing:.04em}
  .toast.show{opacity:1}

  /* Help modal */
  #help{position:fixed;inset:0;background:rgba(0,0,0,.36);display:none;align-items:center;justify-content:center;padding:18px}
  #help[open]{display:flex}
  #help .card{width:min(560px,92vw);background:#fff;border:1px solid var(--line);border-radius:16px;padding:18px}
  #help h3{margin:.2em 0 .6em;font-size:18px;letter-spacing:.12em;text-transform:uppercase;
    font-family:"Bodoni Moda","Didot","Times New Roman",serif;font-weight:700}
  #help ol{padding-left:1.1em;line-height:1.6}
  #help li{margin:.35em 0}
  #help .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="brand">
      <div class="ttl">10 GAME</div>
      <div class="sub">DecaMerge — Circles</div>
    </div>
    <div class="chips">
      <div class="chip">Score: <b id="score">0</b> / Best: <b id="best">0</b></div>
      <div class="nextBadge">
        NEXT
        <div class="nextBubble" id="nextA">-</div>
        <div class="nextBubble" id="nextB">-</div>
      </div>
      <button class="btn ghost" id="helpBtn" aria-haspopup="dialog" aria-controls="help">遊び方</button>
      <button class="btn ghost" id="hintBtn">ヒント ON</button>
      <button class="btn ghost" id="undoBtn" disabled>元に戻す</button>
      <button class="btn strong" id="resetBtn">リセット</button>
    </div>
  </header>

  <div id="stage">
    <canvas id="cv" width="360" height="640" aria-label="10 Game canvas"></canvas>
  </div>

  <footer>
    指で<strong>左右にスライド</strong>→<strong>指を離す</strong>で投入。<br>
    <b>1〜9</b>は<strong>合計=10</strong>で合体（2〜6個／複数同時OK）。<b>同じ大オーブ</b>は<b>倍々合体</b>。
  </footer>
</div>

<!-- How-to -->
<div id="help" role="dialog" aria-modal="true" aria-label="遊び方">
  <div class="card">
    <h3>HOW TO PLAY</h3>
    <ol>
      <li>狙って左右にスライド → 指を離すと投入。</li>
      <li><strong>1〜9</strong>の隣接グループで<strong>合計=10</strong>なら即「10」に合体（2〜6個／複数同時OK）。</li>
      <li><strong>10,20,40…</strong>は<strong>同値接触</strong>で<strong>倍々合体</strong>。</li>
      <li>赤線より上に一定時間あると<b>ゲームオーバー</b>（投入直後0.45秒は無視）。</li>
    </ol>
    <div class="actions">
      <button class="btn ghost" id="closeHelp">閉じる</button>
      <button class="btn strong" id="okHelp">OK</button>
    </div>
  </div>
</div>

<div id="toast" class="toast"></div>

<script>
/* =========================
   実比率（面積 ∝ 値 ⇒ 直径 ∝ √値）＋自動スケール
   - 1280 が盤面に収まるよう SCALE10 を自動調整
   - 1〜5 は“元の見やすさ相当”まで数字フォントを底上げ
   - ベルト関連は完全削除
   ========================= */
const CONFIG = {
  spawnWeights: { 1:6, 2:8, 3:11, 4:13, 5:15, 6:0, 7:0, 8:0, 9:0 },
  baseDFor10: 56,     // 基準（あとで最大値に合わせて自動補正）
  maxRank: 1280,      // ここまでが盤面に入るよう補正
  marginForMax: 8     // 最大球用の余白(px)
};

/* ランダム抽選 */
function makeRandomPicker(weights){
  const table = []; let total = 0;
  for (let v=1; v<=9; v++){ const w = Math.max(0, Number(weights[v] ?? 0)); table.push({v, w}); total += w; }
  if (total <= 0){ table.forEach(t => t.w = 1); total = 9; }
  let acc = 0; for (const row of table){ acc += row.w; row.cum = acc / total; }
  return function pick(){ const r = Math.random(); for (const row of table){ if (r < row.cum) return row.v; } return 9; };
}
const pickSmall = makeRandomPicker(CONFIG.spawnWeights);
const randSmall = ()=> pickSmall();

(()=>{
  // ===== DOM =====
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const nextAEl = document.getElementById('nextA');
  const nextBEl = document.getElementById('nextB');
  const resetBtn = document.getElementById('resetBtn');
  const hintBtn = document.getElementById('hintBtn');
  const undoBtn = document.getElementById('undoBtn');
  const toastEl = document.getElementById('toast');
  const helpBtn = document.getElementById('helpBtn');
  const helpModal = document.getElementById('help');
  const closeHelp = document.getElementById('closeHelp');
  const okHelp = document.getElementById('okHelp');

  // ===== layout fit =====
  function fit(){
    const maxW = Math.min(innerWidth - 24, 440);
    const ratio = maxW / cv.width;
    cv.style.width = maxW+'px';
    cv.style.height = (cv.height*ratio)+'px';
  }
  addEventListener('resize', fit); fit();

  // ===== field & physics =====
  const W = cv.width, H = cv.height;
  const LEFT = 22, RIGHT = W-22, FLOOR = H-14, CEIL = 80; // 赤線
  const BOARD_TOP = 6, BOARD_LEFT = LEFT, BOARD_RIGHT = RIGHT, BOARD_BOTTOM = FLOOR;
  const BOARD_W = RIGHT - LEFT;

  const DT = 1/60, SUBSTEPS = 3, ITER = 4;
  const G = 1850;
  const AIR_FRICTION = 0.975;
  const REST_FLOOR = 0.08;
  const REST_WALL  = 0.10;
  const REST_N     = 0.05;
  const VX_MAX = 980, VY_MAX = 2600;
  const MAX_TILES  = 95;
  const ROT_MAX = 0.11;

  // ===== dynamic scale for real ratios =====
  let SCALE10 = CONFIG.baseDFor10;   // d for value=10
  (function computeAutoScale(){
    const allowed = BOARD_W - CONFIG.marginForMax;               // 盤面許容直径
    const d1280 = SCALE10 * Math.sqrt(CONFIG.maxRank/10);
    if (d1280 > allowed && d1280 > 0){
      const k = allowed / d1280;
      SCALE10 *= k;
    }
  })();

  // ===== game state =====
  /** @type {{x:number,y:number,vx:number,vy:number,h:number,val:number,id:number,m:number,born:number,rot:number}[]} */
  let tiles = [], rings = [];
  let score = 0, over = false, cooldown = 0, gameTime = 0;
  let aimX = (LEFT+RIGHT)/2;
  let nextQ = [randSmall(), randSmall()];
  let showHint = false;
  let dangerTime = 0;
  let idSeq = 1;

  // gesture / modal
  let helpOpen = false, dragging = false, activePointer=null;

  // undo
  let undoState = null;

  // ===== helpers =====
  const CSS = (n)=>getComputedStyle(document.documentElement).getPropertyValue(n).trim();
  const colorSmall = (v)=>CSS('--n'+v);
  function colorBig(v){
    if (v>=640) return CSS('--b640');
    if (v>=320) return CSS('--b320');
    if (v>=160) return CSS('--b160');
    if (v>=80)  return CSS('--b80');
    if (v>=40)  return CSS('--b40');
    if (v>=20)  return CSS('--b20');
    return CSS('--b10');
  }
  function digitColor(val){
    if (val<=9) return CSS('--t'+val);
    if (val>=1280) return CSS('--t1280');
    if (val>=640)  return CSS('--t640');
    if (val>=320)  return CSS('--t320');
    if (val>=160)  return CSS('--t160');
    if (val>=80)   return CSS('--t80');
    if (val>=40)   return CSS('--t40');
    if (val>=20)   return CSS('--t20');
    return CSS('--t10');
  }

  // 実比率：直径 d = SCALE10 * √(val/10)
  function halfFor(val){
    const d = SCALE10 * Math.sqrt(Math.max(val,1)/10);
    return d/2;
  }
  function massFor(r){ return Math.PI * r * r; }

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function updateHUD(){
    scoreEl.textContent = score|0;
    const best = +(localStorage.getItem('decamerge_best_circle_nobelts_v53')||0);
    if (score>best) localStorage.setItem('decamerge_best_circle_nobelts_v53', score|0);
    bestEl.textContent = localStorage.getItem('decamerge_best_circle_nobelts_v53')||0;
    nextAEl.textContent = nextQ[0];
    nextBEl.textContent = nextQ[1];
    hintBtn.textContent = showHint ? 'ヒント OFF' : 'ヒント ON';
    undoBtn.disabled = !undoState;
  }

  // ===== modal open/close =====
  function resetPointerState(){
    try { if (activePointer!==null) cv.releasePointerCapture(activePointer); } catch(e){}
    dragging=false; activePointer=null;
  }
  function openHelp(){ helpOpen=true; helpModal.setAttribute('open',''); resetPointerState(); }
  function closeHelpModal(){ helpOpen=false; helpModal.removeAttribute('open'); resetPointerState(); }
  helpBtn.addEventListener('click', openHelp);
  closeHelp.addEventListener('click', closeHelpModal);
  okHelp.addEventListener('click', closeHelpModal);
  helpModal.addEventListener('click', (e)=>{ if (e.target===helpModal) closeHelpModal(); });
  addEventListener('keydown', (e)=>{ if (e.key==='Escape' && helpOpen) closeHelpModal(); });
  if (!localStorage.getItem('decamerge_seen_help_circle_nobelts_v53')) {
    openHelp(); localStorage.setItem('decamerge_seen_help_circle_nobelts_v53','1');
  }

  // ===== pointer inputs =====
  function canvasX(e){
    const rect = cv.getBoundingClientRect();
    const clientX = e.clientX ?? (e.touches && e.touches[0].clientX) ?? rect.left;
    return (clientX - rect.left) * (cv.width/rect.width);
  }
  function onPointerDown(e){
    if (helpOpen) return;
    if (activePointer !== null) return;
    cv.setPointerCapture(e.pointerId);
    activePointer = e.pointerId;
    dragging = true;
    aimX = clamp(canvasX(e), LEFT, RIGHT);
  }
  function onPointerMove(e){
    if (!dragging || e.pointerId !== activePointer) return;
    aimX = clamp(canvasX(e), LEFT, RIGHT);
  }
  function onPointerUp(e){
    if (e.pointerId !== activePointer) return;
    if (!helpOpen) drop();
    resetPointerState();
  }
  if (window.PointerEvent){
    cv.addEventListener('pointerdown', onPointerDown, {passive:false});
    cv.addEventListener('pointermove', onPointerMove, {passive:false});
    cv.addEventListener('pointerup',   onPointerUp,   {passive:false});
    cv.addEventListener('pointercancel', ()=> resetPointerState(), {passive:true});
  }

  resetBtn.addEventListener('click', reset);
  hintBtn.addEventListener('click', ()=>{ showHint = !showHint; updateHUD(); });
  undoBtn.addEventListener('click', undo);

  // ===== game control =====
  function reset(){
    tiles = []; rings = []; score=0; over=false; cooldown=0; dangerTime=0; gameTime=0;
    aimX=(LEFT+RIGHT)/2; nextQ=[randSmall(), randSmall()]; undoState=null;
    updateHUD();
  }
  function snapshot(){
    return { tiles: tiles.map(t=>({x:t.x,y:t.y,vx:t.vx,vy:t.vy,h:t.h,val:t.val,id:t.id,m:t.m,born:t.born,rot:t.rot})),
             rings: rings.map(r=>({...r})),
             score, over, cooldown, dangerTime, aimX, nextQ:[...nextQ], gameTime };
  }
  function restore(s){
    tiles = s.tiles.map(t=>({...t})); rings = s.rings.map(r=>({...r}));
    score = s.score; over=s.over; cooldown=s.cooldown; dangerTime=s.dangerTime; aimX=s.aimX; nextQ=[...s.nextQ];
    gameTime=s.gameTime; updateHUD();
  }
  function undo(){ if (!undoState) return; restore(undoState); undoState=null; toast('1手戻しました'); }
  function drop(){
    if (over || cooldown>0) return;
    if (tiles.length>=MAX_TILES){ toast('いっぱいです。合体で減らそう！'); return; }
    undoState = snapshot();
    const val = nextQ.shift(); nextQ.push(randSmall());
    const r = halfFor(val);
    const MAX_R_FIT = (BOARD_W - 4)/2;
    const x = (r > MAX_R_FIT) ? (LEFT+RIGHT)/2 : clamp(aimX, LEFT+r+1, RIGHT-r-1);
    tiles.push({x, y: CEIL-30, vx:0, vy:0, h:r, val, id:idSeq++, m:massFor(r), born:gameTime, rot:0});
    score += val; cooldown = .18; updateHUD();
  }

  // ===== physics helpers（円） =====
  const CONTACT_TOL_SMALL = 7;
  const BIG_MERGE_TOL     = 3;

  function keepInside(t){
    const BOUND_SLOP = 0.5;
    const MAX_R_FIT = (BOARD_W - 2)/2;

    // 盤幅を越える巨大球は中央拘束（暴走防止）
    if (t.h > MAX_R_FIT){
      t.x = (LEFT+RIGHT)/2; t.vx = 0;
    }else{
      if (t.x - t.h < LEFT+BOUND_SLOP){ t.x = LEFT+BOUND_SLOP + t.h; t.vx = Math.max(t.vx,0)*(-REST_WALL); }
      if (t.x + t.h > RIGHT-BOUND_SLOP){ t.x = RIGHT-BOUND_SLOP - t.h; t.vx = -Math.max(-t.vx,0)*REST_WALL; }
    }

    if (t.y + t.h > FLOOR-BOUND_SLOP){
      t.y = FLOOR-BOUND_SLOP - t.h;
      if (Math.abs(t.vy) < 40) t.vy = 0; else t.vy = -t.vy * REST_FLOOR;
      if (t.vy === 0){ t.vx *= 0.945; if (Math.abs(t.vx)<6) t.vx = 0; }
    }
    if (t.y - t.h < BOARD_TOP+2) { t.y = BOARD_TOP+2 + t.h; t.vy = Math.max(t.vy,0); }
  }

  function resolvePairs(){
    for (let it=0; it<ITER; it++){
      for (let i=0;i<tiles.length;i++){
        for (let j=i+1;j<tiles.length;j++){
          const A=tiles[i], B=tiles[j];
          const dx=B.x-A.x, dy=B.y-A.y;
          const dist = Math.hypot(dx,dy);
          const minDist = A.h + B.h;
          const overlap = minDist - dist;
          if (overlap>0){
            let nx=1, ny=0;
            if (dist>0){ nx=dx/dist; ny=dy/dist; }
            const imA = 1/A.m, imB = 1/B.m, inv = imA+imB;
            const pushA = (imA/inv)*overlap;
            const pushB = (imB/inv)*overlap;
            A.x -= nx*pushA; A.y -= ny*pushA;
            B.x += nx*pushB; B.y += ny*pushB;
            const rvx=B.vx-A.vx, rvy=B.vy-A.vy;
            const vn=rvx*nx + rvy*ny;
            if (vn<0){
              const j = -(1+REST_N)*vn / (imA+imB);
              A.vx -= j*nx*imA; A.vy -= j*ny*imA;
              B.vx += j*nx*imB; B.vy += j*ny*imB;
            }
          }
        }
      }
      for (const t of tiles) keepInside(t);
    }
  }
  const relaxWorld = (n=4)=>{ for(let i=0;i<n;i++) resolvePairs(); };

  // ===== physics step =====
  function step(dt){
    gameTime += dt;
    cooldown = Math.max(0, cooldown-dt);

    // integrate
    for (const t of tiles){
      t.vy += G*dt;

      // 速度制限・減衰
      t.vx *= AIR_FRICTION; t.vy *= AIR_FRICTION;
      t.vx = clamp(t.vx, -VX_MAX, VX_MAX);
      t.vy = clamp(t.vy, -VY_MAX, VY_MAX);

      t.x += t.vx*dt; t.y += t.vy*dt;

      keepInside(t);

      // 演出用のごく小さな回転
      const target = clamp(t.vx/620, -ROT_MAX, ROT_MAX);
      t.rot += (target - t.rot) * 0.12;
    }

    resolvePairs();

    // merges
    let changed, pass=0; do{ changed = tryMerges(); pass++; } while(changed && pass<16);
    if (changed) relaxWorld(4);

    // fx
    for (const r of rings){ r.t += dt; }
    rings = rings.filter(r=>r.t<0.9);

    // game over
    const AGE_SAFE = 0.45, MARGIN = 1;
    let danger=false;
    for (const t of tiles){
      if (gameTime - t.born < AGE_SAFE) continue;
      if (t.y - t.h <= CEIL - MARGIN){ danger=true; break; }
    }
    dangerTime = danger ? Math.min(10, dangerTime+dt) : 0;
    if (dangerTime > 0.70 && !over){ over=true; toast('GAME OVER! 元に戻す or リセット'); }
  }

  // ===== merging rules（円距離） =====
  const touchingSmall = (a,b)=> Math.hypot(b.x-a.x, b.y-a.y) <= (a.h + b.h + CONTACT_TOL_SMALL);
  const contactBig   = (a,b)=> Math.hypot(b.x-a.x, b.y-a.y) <= (a.h + b.h + BIG_MERGE_TOL);

  function tryMerges(){
    let changed=false;

    // 大オーブ：同値→倍々
    const removedBig = new Set();
    for (let i=0;i<tiles.length;i++){
      const A=tiles[i]; if (A.val<10 || removedBig.has(A.id)) continue;
      for (let j=i+1;j<tiles.length;j++){
        const B=tiles[j]; if (B.val<10 || removedBig.has(B.id)) continue;
        if (A.val===B.val && contactBig(A,B)){
          const out=A.val*2, nx=(A.x+B.x)/2, ny=(A.y+B.y)/2;
          const r=halfFor(out), vx=(A.vx+B.vx)*0.1, vy=(A.vy+B.vy)*0.1;
          tiles.push({x:nx,y:ny,vx,vy,h:r,val:out,id:idSeq++, m:massFor(r), born:gameTime, rot:(A.rot+B.rot)/2});
          removedBig.add(A.id); removedBig.add(B.id);
          rings.push({x:nx,y:ny,t:0,col:colorBig(out)});
          score += Math.max(30,out);
          changed = true;
        }
      }
    }
    if (removedBig.size){ tiles = tiles.filter(t=>!removedBig.has(t.id)); updateHUD(); }

    // 小オーブ：合計=10
    const small = tiles.filter(t=>t.val<10);
    if (small.length){
      const adj = small.map(()=>[]);
      for (let i=0;i<small.length;i++)
        for (let j=i+1;j<small.length;j++)
          if (touchingSmall(small[i], small[j])){ adj[i].push(j); adj[j].push(i); }

      const visited = new Array(small.length).fill(false);
      const toRemove = new Set(); const toAdd = [];

      for (let s=0;s<small.length;s++){
        if (visited[s]) continue;
        const comp=[]; const q=[s]; visited[s]=true;
        while(q.length){ const v=q.shift(); comp.push(v); for (const nb of adj[v]) if(!visited[nb]){visited[nb]=true;q.push(nb);} }
        if (comp.length<2) continue;

        let avail = comp.slice();
        const chosenSets = [];

        while(true){
          let picked=null;
          const sorted = [...avail].sort((ia,ib)=>small[ib].val-small[ia].val);
          function findK(k){
            const arr=sorted, n=arr.length; let res=null;
            function dfs(st, need, sum, ps){
              if (sum>10) return false;
              if (need===0){ if (sum===10){ res=ps; return true; } return false; }
              for (let i=st;i<n;i++){
                const idx=arr[i], v=small[idx].val;
                if (sum+v>10) continue;
                if (dfs(i+1, need-1, sum+v, [...ps, idx])) return true;
              }
              return false;
            }
            return dfs(0,k,0,[]) ? res : null;
          }
          for (const k of [2,3,4,5,6]){ if (avail.length>=k){ const res=findK(k); if (res){ picked=res; break; } } }
          if (picked){
            chosenSets.push(picked);
            const setPicked = new Set(picked);
            avail = avail.filter(i=>!setPicked.has(i));
          }else{ break; }
        }

        for (const picked of chosenSets){
          const chosen = picked.map(i=>small[i]);
          const cx = chosen.reduce((a,b)=>a+b.x,0)/chosen.length;
          const cy = chosen.reduce((a,b)=>a+b.y,0)/chosen.length;
          const cvx= chosen.reduce((a,b)=>a+b.vx,0)/chosen.length * 0.1;
          const cvy= chosen.reduce((a,b)=>a+b.vy,0)/chosen.length * 0.1;
          const r  = halfFor(10);
          toAdd.push({x:cx,y:cy,vx:cvx,vy:cvy,h:r,val:10,id:idSeq++, m:massFor(r), born:gameTime, rot:0});
          chosen.forEach(b=>toRemove.add(b.id));
          rings.push({x:cx,y:cy,t:0,col:colorBig(10)});
          score += 16 + 2*chosen.length;
          changed = true;
        }
      }

      if (toRemove.size){
        tiles = tiles.filter(t=>!toRemove.has(t.id));
        tiles.push(...toAdd);
        updateHUD();
      }
    }

    return changed;
  }

  // ===== rendering =====
  function draw(){
    ctx.clearRect(0,0,W,H);

    // 外枠（ヘアライン）
    ctx.strokeStyle = CSS('--line'); ctx.lineWidth = 1.5;
    roundedRectPath(LEFT-8, 6, RIGHT-LEFT+16, FLOOR-6, 18); ctx.stroke();

    // 盤面内クリップ
    ctx.save(); ctx.beginPath();
    ctx.rect(BOARD_LEFT, BOARD_TOP, BOARD_RIGHT-BOARD_LEFT, BOARD_BOTTOM-BOARD_TOP);
    ctx.clip();

    // 赤線
    ctx.strokeStyle = 'rgba(226,78,82,.65)';
    ctx.setLineDash([6,4]); ctx.beginPath(); ctx.moveTo(LEFT, CEIL); ctx.lineTo(RIGHT, CEIL); ctx.stroke(); ctx.setLineDash([]);

    // ゴースト（巨大球は中央表示）
    const rN = halfFor(nextQ[0]);
    const MAX_R_FIT = (BOARD_W - 4)/2;
    const ax = (rN > MAX_R_FIT) ? (LEFT+RIGHT)/2 : clamp(aimX, LEFT+rN+1, RIGHT-rN-1);
    ctx.globalAlpha=.26; drawOrb(ax, CEIL-28, rN, nextQ[0], 0); ctx.globalAlpha=1;

    // オーブ
    for (const t of tiles) drawOrb(t.x,t.y,t.h,t.val,t.rot);

    // 合体リング
    for (const rr of rings){
      ctx.globalAlpha = Math.max(0, 1 - rr.t*1.1);
      ctx.strokeStyle = rr.col; ctx.lineWidth = 2.2;
      const r = 8 + rr.t*42;
      ctx.beginPath(); ctx.arc(rr.x, rr.y, r, 0, Math.PI*2); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.restore();

    if (over){
      ctx.fillStyle = 'rgba(0,0,0,.48)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font='700 30px "Bodoni Moda","Didot","Times New Roman",serif';
      ctx.fillText('GAME OVER', W/2, H*0.42);
      ctx.font='600 15px ui-sans-serif, "Noto Sans JP", system-ui';
      ctx.fillText('「元に戻す」または「リセット」', W/2, H*0.58);
    }
  }

  // ★ 数字カラー化＋小値フォントの底上げ
  function drawOrb(x,y,r,val,rot){
    ctx.save(); ctx.translate(x,y); ctx.rotate(rot||0);

    // 本体（内側から僅かに光らせる）
    const g = ctx.createRadialGradient(-r*0.28, -r*0.28, r*0.18, 0, 0, r);
    const base = val<10 ? colorSmall(val) : colorBig(val);
    g.addColorStop(0, '#FFFFFF');
    g.addColorStop(1, base);
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();

    // 外枠（極細）
    ctx.strokeStyle='rgba(0,0,0,.14)'; ctx.lineWidth=1.8;
    ctx.beginPath(); ctx.arc(0,0,r-0.6,0,Math.PI*2); ctx.stroke();

    // 数字（Didone系）
    ctx.textAlign='center'; ctx.textBaseline='middle';

    // 通常は r*1.12。★1〜5は“元の見え方”相当まで底上げ
    // 参考：旧v5.0の基準直径=56 → 参照半径 r_ref = 56*√(val/10)/2
    const REF_D10 = 56;
    const r_ref = (REF_D10 * Math.sqrt(Math.max(val,1)/10)) / 2;
    let fontPx = Math.floor(r*1.12);
    if (val <= 5){
      const legacy = Math.floor(r_ref*1.16);
      fontPx = Math.max(fontPx, legacy, 18); // 最低18pxは確保
    }
    ctx.font = '700 '+fontPx+'px "Bodoni Moda","Didot","Times New Roman",serif';

    // 読みやすさの白縁
    ctx.lineWidth = Math.max(1.8, r*0.16);
    ctx.strokeStyle = 'rgba(255,255,255,0.92)';
    ctx.strokeText(val, 0, 1);

    // 値ごとに数字色を変える（要望）
    ctx.fillStyle = digitColor(val) || '#111';
    ctx.fillText(val, 0, 1);

    if (showHint && val<10){
      ctx.fillStyle='rgba(0,0,0,.34)'; ctx.font=Math.floor(Math.max(fontPx*0.55, 14))+'px ui-sans-serif, "Noto Sans JP"';
      ctx.fillText(10-val, 0, -r*1.1);
    }
    ctx.restore();
  }

  function roundedRectPath(x,y,w,h,r){
    ctx.beginPath(); ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  }

  // ===== main loop =====
  const toast = (msg)=>{ toastEl.textContent=msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'), 1300); };
  let acc=0, last=performance.now();
  function loop(now){
    const dt = (now-last)/1000; last=now; acc += dt;
    while(acc>DT){
      const sdt = DT/SUBSTEPS;
      for (let k=0;k<SUBSTEPS;k++) step(sdt);
      acc -= DT;
    }
    draw(); requestAnimationFrame(loop);
  }
  reset(); updateHUD(); requestAnimationFrame(loop);
})();
</script>

<!-- Service Worker（オフライン対応・キャッシュ名更新） -->
<script>
if ('serviceWorker' in navigator) {
  const code = `
    const CACHE='10game-decamerge-circle-v53-nobelts';
    self.addEventListener('install',e=>{
      e.waitUntil(caches.open(CACHE).then(c=>c.addAll(['./'])));
      self.skipWaiting();
    });
    self.addEventListener('activate',e=>{
      e.waitUntil(caches.keys().then(keys=>Promise.all(keys.map(k=>k!==CACHE&&caches.delete(k)))));
      self.clients.claim();
    });
    self.addEventListener('fetch',e=>{
      e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request)));
    });
  `;
  const blob = new Blob([code], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  addEventListener('load', () => navigator.serviceWorker.register(url));
}
</script>
</body>
</html>
